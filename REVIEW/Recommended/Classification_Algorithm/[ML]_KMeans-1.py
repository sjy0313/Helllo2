#!/usr/bin/env python
# coding: utf-8

# K-평균 군집화(K-means Clustering)
# 비지도학습의 대표적인 알고리즘으로 목표변수가 없는 상태에서 데이터를 비슷한 유형끼리 묶는 머신러닝 기법이다.
# K-최근접 이웃 알고리즘과 비슷하게 거리 기반으로 작동하며 적절한 K값을 사용자가 지정해야 한다.
# 거리 기반으로 작동하기 때문에 데이터 위치가 가까운 데이터끼리 한 그룹으로 묶는다.
# 전체 그룹의 수는 사용자가 지정한 K개이다.
#
# 장점:
#   - 구현이 간단하다.
#   - 클러스터링 결과를 쉽게 해석할 수 있다.

# 단점:
#   - 최적의 K값을 자동으로 찾지 못하고 사용자가 직접 선택해야 한다.
#   - 거리 기반 알고리즘이기 때문에 변수의 스케일에 따라 다른 결과를 나타낼 수 있다.
#
# 유용한 곳:
#   - 종속변수가 없는 데이터셋에서 데이터 특성을 비교적 간단하게 살펴보는 용도로 활용할 수 있다.
#   - 마케팅이나 제품 기획 등을 목적으로 한 고객 분류에 사용할 수 있다.
#   - 지도 학습에서 종속변수를 제외하면, 탐색적 자료 분석 혹은 피처 엔지니어링 용도로 사용할 수 있다.     
#
# 시나리오:
#   - 온라인 쇼핑몰의 고객이 구매한 물품, 검색한 물품, 살펴본 물품 정보를 이용해 고객에게 추천 서버스를 제공
#   - 다양한 변수를 활용하여 다양한 방식으로 고객 그룹을 분류
#   - 고객 데이터셋을 분석하여 적당한 수의 그룹으로 묶어보고
#     각 그룹별로 어떤 특성이 있는지 알아 봄    
#
# 문제유형
#   - 비지도학습
# 
# 평가지표:
#   - 엘보우 기법
#   - 실루엣 점수    

#%%

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#%%

# 샘플 데이터셋
file_url = '../dataset/[ML]_KMeans.csv'
data = pd.read_csv(file_url)

#%%

data

#%%

# 산점도 그리기
sns.scatterplot(x='var_1', y = 'var_2', data= data)

#%%

# 데이터 모델링 및 평가
from sklearn.cluster import KMeans


#%%

# 모델 객체 생성
# 그룹수: n_clusters=3
kmeans_model = KMeans(n_clusters=3, random_state = 100)

#%%

# 모델 학습
kmeans_model.fit(data)

#%%

# 데이터들을 클러스터로 분류
# 예측
# 결과 : 0, 1, 2
kmeans_model.predict(data)

#%%

# 예측값을 레이블(label)로 저장
data['label'] = kmeans_model.predict(data)

#%%

# 예측 결과를 확인
# 산점도
sns.scatterplot(x='var_1', y = 'var_2', data= data, hue='label', palette='rainbow')


#%%

###############################################################################
# 엘보우 기법으로 최적의 K값 구하기
##############################################################################
# 엘보우 기법(elbow method)
#   - 최적의 클러스터 개수를 확인하는 방법
#   - 클러스터의 중점과 각 데이터 간의 거리를 기반으로 계산
# 이너셔(inertia)
#   - 각 그룹에서의 중심과 각 그룹에 해당하는 데이터 간의 거리에 대한 합
#   - 작을수록 그룹별로 더 오밀조밀 잘 모이게 분류됐다고 할 수 있다.
#   - K 값이 커지면 거리의 합인 이너셔는 필연적으로 작아지게 된다.
#   - 유의미한 클러스터를 만들어서 어떠한 집단적 특징을 찾는 것이 목적

#%%

# 이너셔 확인
kmeans_model.inertia_
# 3090.033237076661

#%%

# 예시
# 클러스터 : 500개
temp_model = KMeans(n_clusters=500, random_state = 100)
temp_model.fit(data)
temp_model.inertia_ # 6.341205909239223

#%%

# 예시
# K의 범위를 2부터 10까 지정해서 모델링을 반복
distance = []   
for k in range(2,10):
    k_model = KMeans(n_clusters=k)
    k_model.fit(data)    
    distance.append(k_model.inertia_) 

#%%

distance

#%%

# 거리값
# K가 2부터 9까지일 때 각 이너셔의 값
"""
[9908.551424778396,
 3090.033237076661,
 2753.349033620961,
 2438.9508032819062,
 2164.982051244451,
 1892.7239482818509,
 1604.9062103820856,
 1497.923525642204]
"""

#%%

# 선형 그래프
# 엘보우 플랏
sns.lineplot(x=range(2,10), y=distance)

#%%

# 결과분석:
#   - K가 3인 지점에서 y가 크게 감소
#   - K가 3인 지점은 팔꿈치를 연상하게 하기 때문에 엘보우 기법이라 부름
#   - 거리가 급격히 줄어드는 K값을 포착하여 최적의 K값을 찾도록 도와주는 방법론

#%%

# THE END